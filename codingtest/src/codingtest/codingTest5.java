package codingtest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;
import java.util.StringTokenizer;
//양
//문제
//미키의 뒷마당에는 특정 수의 양이 있다. 그가 푹 잠든 사이에 배고픈 늑대는 마당에 들어와 양을 공격했다.
//
//마당은 행과 열로 이루어진 직사각형 모양이다. 글자 '.' (점)은 빈 필드를 의미하며, 글자 '#'는 울타리를, 'o'는 양, 'v'는 늑대를 의미한다.
//
//한 칸에서 수평, 수직만으로 이동하며 울타리를 지나지 않고 다른 칸으로 이동할 수 있다면, 두 칸은 같은 영역 안에 속해 있다고 한다. 마당에서 "탈출"할 수 있는 칸은 어떤 영역에도 속하지 않는다고 간주한다.
//
//다행히 우리의 양은 늑대에게 싸움을 걸 수 있고 영역 안의 양의 수가 늑대의 수보다 많다면 이기고, 늑대를 우리에서 쫓아낸다. 그렇지 않다면 늑대가 그 지역 안의 모든 양을 먹는다.
//
//맨 처음 모든 양과 늑대는 마당 안 영역에 존재한다.
//
//아침이 도달했을 때 살아남은 양과 늑대의 수를 출력하는 프로그램을 작성하라.
//
//입력
//첫 줄에는 두 정수 R과 C가 주어지며(3 ≤ R, C ≤ 250), 각 수는 마당의 행과 열의 수를 의미한다.
//
//다음 R개의 줄은 C개의 글자를 가진다. 이들은 마당의 구조(울타리, 양, 늑대의 위치)를 의미한다.
//
//출력
//하나의 줄에 아침까지 살아있는 양과 늑대의 수를 의미하는 두 정수를 출력한다.
//
//예제 입력 1 
//6 6
//...#..
//.##v#.
//#v.#.#
//#.o#.#
//.###.#
//...###
//예제 출력 1 
//0 2

public class codingTest5 {
	static char[][] map;
	static boolean[][] visited;
	static int n,m;
	static int[] dx = {0,0,1,-1};
	static int[] dy = {1,-1,0,0};
	
	private static Queue<int[]> bfs(int i, int j) {
		int sheep = 0;
		int wolf = 0;
		if(map[i][j] == 'v') {
			wolf = 1;
		}
		if(map[i][j] == 'o') {
			sheep = 1;
		}
		visited[i][j] = true;
		Queue<int[]> q = new LinkedList<int[]>();
		q.add(new int[] {i,j});
		while (!q.isEmpty()) {
			int y = q.peek()[0];
			int x = q.peek()[1];
			q.poll();
			for(int k = 0; k<4; k++) {
				int ny = y + dy[k];
				int nx = x + dx[k];
				if(ny<0 || ny>=n || nx<0 || nx>=m) continue;
				if(visited[ny][nx] || map[ny][nx] == '#') continue;
				visited[ny][nx] = true;
				q.add(new int[] {ny,nx});
				if(map[ny][nx] == 'o') {
//					System.out.println("o증가 "+ny+" "+nx);
					sheep++;
				}
				if(map[ny][nx] == 'v') {
//					System.out.println("v증가 "+ny+" "+nx);
					wolf++;
				}//if
			}//for
		}//while
		Queue<int[]> q1 = new LinkedList<int[]>();
		q1.add(new int[] {sheep, wolf});
		return q1;
	}
	
	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		n = Integer.parseInt(st.nextToken());
		m = Integer.parseInt(st.nextToken());
		map = new char[n][m];
		visited = new boolean[n][m];
		for(int i = 0; i<n; i++) {
			String s = br.readLine();
			for(int j = 0; j<m; j++) {
				map[i][j] = s.charAt(j); 
			}//for
		}//for
		int sheep = 0;
		int wolf = 0;
		for(int i = 0; i<n; i++) {
			for(int j = 0; j<m; j++) {
				//#이거나 이미 방문했으면 패스
				if(visited[i][j] || map[i][j] == '#') continue;
				Queue<int[]> sheep_wolf = bfs(i, j);
				int sheep0 = sheep_wolf.peek()[0];
				int wolf0 = sheep_wolf.peek()[1];
				sheep_wolf.poll();
				if(sheep0>wolf0) {
					sheep += sheep0;
				}
				else {
					wolf += wolf0;
				}
				
			}//for
		}//for
		System.out.println(sheep+" "+wolf);		
	}

}
